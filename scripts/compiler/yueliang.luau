--#selene: allow(multiple_statements, undefined_variable, incorrect_standard_library_use, shadowing, divide_by_zero, unbalanced_assignments, empty_if)
--!nocheck
--!nolint
--!native
--!optimize 2
-- This is Yueliang, credits to original creators;

local d={} local g={} local i={} local j={} local e={} local k={} local b=8 local function h(_)if not _ then error"assertion failed!"end end function d.make_getS(_,_)local a=_ return function()if not a then return nil end local _=a a=nil return _ end end function d.make_getF(_,a)local b=512 local c=1 return function()local _=a:sub(c,c+b-1) c=math.min(#a+1,c+b) return _ end end function d.init(_,_,a)if not _ then return end local b={} b.reader=_ b.data=a or"" b.name=name if not a or a==""then b.n=0 else b.n=#a end b.p=0 return b end function d.fill(_,_)local a=_.reader() _.data=a if not a or a==""then return"EOZ"end _.n,_.p=#a-1,1 return string.sub(a,1,1)end function d.zgetc(_,c)local a,b=c.n,c.p+1 if a>0 then c.n,c.p=a-1,b return string.sub(c.data,b,b)else return _:fill(c)end end i.RESERVED=[[
TK_AND and
TK_BREAK break
TK_DO do
TK_ELSE else
TK_ELSEIF elseif
TK_END end
TK_FALSE false
TK_FOR for
TK_FUNCTION function
TK_IF if
TK_IN in
TK_LOCAL local
TK_NIL nil
TK_NOT not
TK_OR or
TK_REPEAT repeat
TK_RETURN return
TK_THEN then
TK_TRUE true
TK_UNTIL until
TK_WHILE while
TK_CONCAT ..
TK_DOTS ...
TK_EQ ==
TK_GE >=
TK_LE <=
TK_NE ~=
TK_NAME <name>
TK_NUMBER <number>
TK_STRING <string>
TK_EOS <eof>]] i.MAXSRC=80 i.MAX_INT=2147483645 i.LUA_QS="'%s'" i.LUA_COMPAT_LSTR=1 function i.init(_)local a,c={},{} for _ in string.gmatch(_.RESERVED,"[^\n]+")do local _,_,b,_=string.find(_,"(%S+)%s+(%S+)") a[b]=_ c[_]=b end _.tokens=a _.enums=c end function i.chunkid(_,b,a)local c local _=string.sub(b,1,1) if _=="="then c=string.sub(b,2,a)else if _=="@"then b=string.sub(b,2) a=a-#" '...' " local _=#b c="" if _>a then b=string.sub(b,1+_-a) c=c.."..."end c=c..b else local _=string.find(b,"[\n\r]") _=_ and(_-1)or#b a=a-#(" [string \"...\"] ") if _>a then _=a end c="[string \"" if _<#b then c=c..string.sub(b,1,_).."..."else c=c..b end c=c.."\"]"end end return c end function i.token2str(a,_,_)if string.sub(_,1,3)~="TK_"then if string.find(_,"%c")then return string.format("char(%d)",string.byte(_))end return _ else return a.tokens[_]end end function i.lexerror(e,d,_,c)local function b(_,a)if a=="TK_NAME"or a=="TK_STRING"or a=="TK_NUMBER"then return _.buff else return e:token2str(_,a)end end local a=e:chunkid(d.source,e.MAXSRC) local _=string.format("%s:%d: %s",a,d.linenumber,_) if c then _=string.format("%s near "..e.LUA_QS,_,b(d,c))end error(_)end function i.syntaxerror(a,b,_)a:lexerror(b,_,b.t.token)end function i.currIsNewline(_,_)return _.current=="\n"or _.current=="\r"end function i.inclinenumber(a,b)local _=b.current a:nextc(b) if a:currIsNewline(b)and b.current~=_ then a:nextc(b)end b.linenumber=b.linenumber+1 if b.linenumber>=a.MAX_INT then a:syntaxerror(b,"chunk has too many lines")end end function i.setinput(_,a,d,b,c)if not d then d={}end if not d.lookahead then d.lookahead={}end if not d.t then d.t={}end d.decpoint="." d.L=a d.lookahead.token="TK_EOS" d.z=b d.fs=nil d.linenumber=1 d.lastline=1 d.source=c _:nextc(d)end function i.check_next(_,b,a)if not string.find(a,b.current,1,1)then return false end _:save_and_next(b) return true end function i.next(_,a)a.lastline=a.linenumber if a.lookahead.token~="TK_EOS"then a.t.seminfo=a.lookahead.seminfo a.t.token=a.lookahead.token a.lookahead.token="TK_EOS"else a.t.token=_:llex(a,a.t)end end function i.lookahead(_,a)a.lookahead.token=_:llex(a,a.lookahead)end function i.nextc(_,a)local _=d:zgetc(a.z) a.current=_ return _ end function i.save(_,b,a)local _=b.buff b.buff=_..a end function i.save_and_next(_,a)_:save(a,a.current) return _:nextc(a)end function i.str2d(_,_)local a=tonumber(_) if a then return a end if string.lower(string.sub(_,1,2))=="0x"then a=tonumber(_,16) if a then return a end end return nil end function i.buffreplace(_,b,_,a)local d,c="",b.buff for b=1,#c do local b=string.sub(c,b,b) if b==_ then b=a end d=d..b end b.buff=d end function i.trydecpoint(b,c,_)local a=c.decpoint b:buffreplace(c,a,c.decpoint) local a=b:str2d(c.buff) _.seminfo=a if not a then b:buffreplace(c,c.decpoint,".") b:lexerror(c,"malformed number","TK_NUMBER")end end function i.read_numeral(b,c,_)repeat b:save_and_next(c)until string.find(c.current,"%D")and c.current~="." if b:check_next(c,"Ee")then b:check_next(c,"+-")end while string.find(c.current,"^%w$")or c.current=="_"do b:save_and_next(c)end b:buffreplace(c,".",c.decpoint) local a=b:str2d(c.buff) _.seminfo=a if not a then b:trydecpoint(c,_)end end function i.skip_sep(a,c)local b=0 local _=c.current a:save_and_next(c) while c.current=="="do a:save_and_next(c) b=b+1 end return(c.current==_)and b or(-b)-1 end function i.read_long_string(e,d,a,c)local b=0 e:save_and_next(d) if e:currIsNewline(d)then e:inclinenumber(d)end while true do local _=d.current if _=="EOZ"then e:lexerror(d,a and"unfinished long string"or"unfinished long comment","TK_EOS")elseif _=="["then if e.LUA_COMPAT_LSTR then if e:skip_sep(d)==c then e:save_and_next(d) b=b+1 if e.LUA_COMPAT_LSTR==1 then if c==0 then e:lexerror(d,"nesting of [[...]] is deprecated","[")end end end end elseif _=="]"then if e:skip_sep(d)==c then e:save_and_next(d) if e.LUA_COMPAT_LSTR and e.LUA_COMPAT_LSTR==2 then b=b-1 if c==0 and b>=0 then break end end break end elseif e:currIsNewline(d)then e:save(d,"\n") e:inclinenumber(d) if not a then d.buff=""end else if a then e:save_and_next(d)else e:nextc(d)end end end if a then local _=3+c a.seminfo=string.sub(d.buff,_,-_)end end function i.read_string(b,c,a,_)b:save_and_next(c) while c.current~=a do local a=c.current if a=="EOZ"then b:lexerror(c,"unfinished string","TK_EOS")elseif b:currIsNewline(c)then b:lexerror(c,"unfinished string","TK_STRING")elseif a=="\\"then a=b:nextc(c) if b:currIsNewline(c)then b:save(c,"\n") b:inclinenumber(c)elseif a~="EOZ"then local _=string.find("abfnrtv",a,1,1) if _ then b:save(c,string.sub("\a\b\f\n\r\t\v",_,_)) b:nextc(c)elseif not string.find(a,"%d")then b:save_and_next(c)else a,_=0,0 repeat a=10*a+c.current b:nextc(c) _=_+1 until _>=3 or not string.find(c.current,"%d") if a>255 then b:lexerror(c,"escape sequence too large","TK_STRING")end b:save(c,string.char(a))end end else b:save_and_next(c)end end b:save_and_next(c) _.seminfo=string.sub(c.buff,2,-2)end function i.llex(c,a,b)a.buff="" while true do local _=a.current if c:currIsNewline(a)then c:inclinenumber(a)elseif _=="-"then _=c:nextc(a) if _~="-"then return"-"end local _=-1 if c:nextc(a)=='['then _=c:skip_sep(a) a.buff=""end if _>=0 then c:read_long_string(a,nil,_) a.buff=""else while not c:currIsNewline(a)and a.current~="EOZ"do c:nextc(a)end end elseif _=="["then local _=c:skip_sep(a) if _>=0 then c:read_long_string(a,b,_) return"TK_STRING"elseif _==-1 then return"["else c:lexerror(a,"invalid long string delimiter","TK_STRING")end elseif _=="="then _=c:nextc(a) if _~="="then return"="else c:nextc(a) return"TK_EQ"end elseif _=="<"then _=c:nextc(a) if _~="="then return"<"else c:nextc(a) return"TK_LE"end elseif _==">"then _=c:nextc(a) if _~="="then return">"else c:nextc(a) return"TK_GE"end elseif _=="~"then _=c:nextc(a) if _~="="then return"~"else c:nextc(a) return"TK_NE"end elseif _=="\""or _=="'"then c:read_string(a,_,b) return"TK_STRING"elseif _=="."then _=c:save_and_next(a) if c:check_next(a,".")then if c:check_next(a,".")then return"TK_DOTS"else return"TK_CONCAT"end elseif not string.find(_,"%d")then return"."else c:read_numeral(a,b) return"TK_NUMBER"end elseif _=="EOZ"then return"TK_EOS"else if string.find(_,"%s")then c:nextc(a)elseif string.find(_,"%d")then c:read_numeral(a,b) return"TK_NUMBER"elseif string.find(_,"[_%a]")then repeat _=c:save_and_next(a)until _=="EOZ"or not string.find(_,"[_%w]") local a=a.buff local _=c.enums[a] if _ then return _ end b.seminfo=a return"TK_NAME"else c:nextc(a) return _ end end end end j.OpMode={iABC=0,iABx=1,iAsBx=2} j.SIZE_C=9 j.SIZE_B=9 j.SIZE_Bx=j.SIZE_C+j.SIZE_B j.SIZE_A=8 j.SIZE_OP=6 j.POS_OP=0 j.POS_A=j.POS_OP+j.SIZE_OP j.POS_C=j.POS_A+j.SIZE_A j.POS_B=j.POS_C+j.SIZE_C j.POS_Bx=j.POS_C j.MAXARG_Bx=math.ldexp(1,j.SIZE_Bx)-1 j.MAXARG_sBx=math.floor(j.MAXARG_Bx/2) j.MAXARG_A=math.ldexp(1,j.SIZE_A)-1 j.MAXARG_B=math.ldexp(1,j.SIZE_B)-1 j.MAXARG_C=math.ldexp(1,j.SIZE_C)-1 function j.GET_OPCODE(a,_)return a.ROpCode[_.OP]end function j.SET_OPCODE(a,_,b)_.OP=a.OpCode[b]end function j.GETARG_A(_,_)return _.A end function j.SETARG_A(_,a,_)a.A=_ end function j.GETARG_B(_,_)return _.B end function j.SETARG_B(_,_,a)_.B=a end function j.GETARG_C(_,_)return _.C end function j.SETARG_C(_,_,a)_.C=a end function j.GETARG_Bx(_,_)return _.Bx end function j.SETARG_Bx(_,_,a)_.Bx=a end function j.GETARG_sBx(_,a)return a.Bx-_.MAXARG_sBx end function j.SETARG_sBx(b,_,a)_.Bx=a+b.MAXARG_sBx end function j.CREATE_ABC(d,b,a,c,_)return{OP=d.OpCode[b],A=a,B=c,C=_}end function j.CREATE_ABx(_,b,a,c)return{OP=_.OpCode[b],A=a,Bx=c}end function j.CREATE_Inst(_,c)local a=c%64 c=(c-a)/64 local b=c%256 c=(c-b)/256 return _:CREATE_ABx(a,b,c)end function j.Instruction(_,c)if c.Bx then c.C=c.Bx%512 c.B=(c.Bx-c.C)/512 end local _=c.A*64+c.OP local a=_%256 _=c.C*64+(_-a)/256 local b=_%256 _=c.B*128+(_-b)/256 local c=_%256 local _=(_-c)/256 return string.char(a,b,c,_)end function j.DecodeInst(_,d)local c=string.byte local e={} local f=c(d,1) local b=f%64 e.OP=b f=c(d,2)*4+(f-b)/64 local a=f%256 e.A=a f=c(d,3)*4+(f-a)/256 local a=f%512 e.C=a e.B=c(d,4)*2+(f-a)/512 local _=_.OpMode[tonumber(string.sub(_.opmodes[b+1],7,7))] if _~="iABC"then e.Bx=e.B*512+e.C end return e end j.BITRK=math.ldexp(1,j.SIZE_B-1) function j.ISK(a,_)return _>=a.BITRK end function j.INDEXK(a,_)return x-a.BITRK end j.MAXINDEXRK=j.BITRK-1 function j.RKASK(a,_)return _+a.BITRK end j.NO_REG=j.MAXARG_A j.opnames={} j.OpCode={} j.ROpCode={} local c=0 for a in string.gmatch([[
MOVE LOADK LOADBOOL LOADNIL GETUPVAL
GETGLOBAL GETTABLE SETGLOBAL SETUPVAL SETTABLE
NEWTABLE SELF ADD SUB MUL
DIV MOD POW UNM NOT
LEN CONCAT JMP EQ LT
LE TEST TESTSET CALL TAILCALL
RETURN FORLOOP FORPREP TFORLOOP SETLIST
CLOSE CLOSURE VARARG
]],"%S+")do local _="OP_"..a j.opnames[c]=a j.OpCode[_]=c j.ROpCode[c]=_ c=c+1 end j.NUM_OPCODES=c j.OpArgMask={OpArgN=0,OpArgU=1,OpArgR=2,OpArgK=3} function j.getOpMode(a,_)return a.opmodes[a.OpCode[_]]%4 end function j.getBMode(a,_)return math.floor(a.opmodes[a.OpCode[_]]/16)%4 end function j.getCMode(a,_)return math.floor(a.opmodes[a.OpCode[_]]/4)%4 end function j.testAMode(a,_)return math.floor(a.opmodes[a.OpCode[_]]/64)%2 end function j.testTMode(a,_)return math.floor(a.opmodes[a.OpCode[_]]/128)end j.LFIELDS_PER_FLUSH=50 local function _(_,b,a,c,d)local e=j return _*128+b*64+e.OpArgMask[a]*16+e.OpArgMask[c]*4+e.OpMode[d]end j.opmodes={_(0,1,"OpArgK","OpArgN","iABx"),_(0,1,"OpArgU","OpArgU","iABC"),_(0,1,"OpArgR","OpArgN","iABC"),_(0,1,"OpArgU","OpArgN","iABC"),_(0,1,"OpArgK","OpArgN","iABx"),_(0,1,"OpArgR","OpArgK","iABC"),_(0,0,"OpArgK","OpArgN","iABx"),_(0,0,"OpArgU","OpArgN","iABC"),_(0,0,"OpArgK","OpArgK","iABC"),_(0,1,"OpArgU","OpArgU","iABC"),_(0,1,"OpArgR","OpArgK","iABC"),_(0,1,"OpArgK","OpArgK","iABC"),_(0,1,"OpArgK","OpArgK","iABC"),_(0,1,"OpArgK","OpArgK","iABC"),_(0,1,"OpArgK","OpArgK","iABC"),_(0,1,"OpArgK","OpArgK","iABC"),_(0,1,"OpArgK","OpArgK","iABC"),_(0,1,"OpArgR","OpArgN","iABC"),_(0,1,"OpArgR","OpArgN","iABC"),_(0,1,"OpArgR","OpArgN","iABC"),_(0,1,"OpArgR","OpArgR","iABC"),_(0,0,"OpArgR","OpArgN","iAsBx"),_(1,0,"OpArgK","OpArgK","iABC"),_(1,0,"OpArgK","OpArgK","iABC"),_(1,0,"OpArgK","OpArgK","iABC"),_(1,1,"OpArgR","OpArgU","iABC"),_(1,1,"OpArgR","OpArgU","iABC"),_(0,1,"OpArgU","OpArgU","iABC"),_(0,1,"OpArgU","OpArgU","iABC"),_(0,0,"OpArgU","OpArgN","iABC"),_(0,1,"OpArgR","OpArgN","iAsBx"),_(0,1,"OpArgR","OpArgN","iAsBx"),_(1,0,"OpArgN","OpArgU","iABC"),_(0,0,"OpArgU","OpArgU","iABC"),_(0,0,"OpArgN","OpArgN","iABC"),_(0,1,"OpArgU","OpArgN","iABx"),_(0,1,"OpArgU","OpArgN","iABC")} j.opmodes[0]=_(0,1,"OpArgR","OpArgN","iABC") e.LUA_SIGNATURE="\27Lua" e.LUA_TNUMBER=3 e.LUA_TSTRING=4 e.LUA_TNIL=0 e.LUA_TBOOLEAN=1 e.LUA_TNONE=-1 e.LUAC_VERSION=0x51 e.LUAC_FORMAT=0 e.LUAC_HEADERSIZE=12 function e.make_setS(_)local a={} a.data="" local _=function(a,_)if not a then return 0 end _.data=_.data..a return 0 end return _,a end function e.make_setF(_,_)local a={} a.h=io.open(_,"wb") if not a.h then return nil end local _=function(_,a)if not a.h then return 0 end if not _ then if a.h:close()then return 0 end else if a.h:write(_)then return 0 end end return 1 end return _,a end function e.ttype(a,_)local _=type(_.value) if _=="number"then return a.LUA_TNUMBER elseif _=="string"then return a.LUA_TSTRING elseif _=="nil"then return a.LUA_TNIL elseif _=="boolean"then return a.LUA_TBOOLEAN else return a.LUA_TNONE end end function e.from_double(_,f)local function a(a)local _=a%256 return(a-_)/256,string.char(_)end local _=0 if f<0 then _=1 f=-f end local b,c=math.frexp(f) if f==0 then b,c=0,0 elseif f==1/0 then b,c=0,2047 else b=(b*2-1)*math.ldexp(0.5,53) c=c+1022 end local e,d="" f=math.floor(b) for _=1,6 do f,d=a(f) e=e..d end f,d=a(c*16+f) e=e..d f,d=a(_*128+f) e=e..d return e end function e.from_int(_,b)local a="" b=math.floor(b) if b<0 then b=4294967296+b end for _=1,4 do local _=b%256 a=a..string.char(_) b=math.floor(b/256)end return a end function e.DumpBlock(_,_,a)if a.status==0 then a.status=a.write(_,a.data)end end function e.DumpChar(b,_,a)b:DumpBlock(string.char(_),a)end function e.DumpInt(b,_,a)b:DumpBlock(b:from_int(_),a)end function e.DumpSizeT(c,_,a)c:DumpBlock(c:from_int(_),a) if b==8 then c:DumpBlock(c:from_int(0),a)end end function e.DumpNumber(b,_,a)b:DumpBlock(b:from_double(_),a)end function e.DumpString(_,b,a)if b==nil then _:DumpSizeT(0,a)else b=b.."\0" _:DumpSizeT(#b,a) _:DumpBlock(b,a)end end function e.DumpCode(a,c,b)local _=c.sizecode a:DumpInt(_,b) for _=0,_-1 do a:DumpBlock(j:Instruction(c.code[_]),b)end end function e.DumpConstants(c,a,b)local _=a.sizek c:DumpInt(_,b) for _=0,_-1 do local _=a.k[_] local a=c:ttype(_) c:DumpChar(a,b) if a==c.LUA_TNIL then elseif a==c.LUA_TBOOLEAN then c:DumpChar(_.value and 1 or 0,b)elseif a==c.LUA_TNUMBER then c:DumpNumber(_.value,b)elseif a==c.LUA_TSTRING then c:DumpString(_.value,b)end end _=a.sizep c:DumpInt(_,b) for _=0,_-1 do c:DumpFunction(a.p[_],a.source,b)end end function e.DumpDebug(b,a,c)local _ _=c.strip and 0 or a.sizelineinfo b:DumpInt(_,c) for _=0,_-1 do b:DumpInt(a.lineinfo[_],c)end _=c.strip and 0 or a.sizelocvars b:DumpInt(_,c) for _=0,_-1 do b:DumpString(a.locvars[_].varname,c) b:DumpInt(a.locvars[_].startpc,c) b:DumpInt(a.locvars[_].endpc,c)end _=c.strip and 0 or a.sizeupvalues b:DumpInt(_,c) for _=0,_-1 do b:DumpString(a.upvalues[_],c)end end function e.DumpFunction(c,b,_,d)local a=b.source if a==_ or d.strip then a=nil end c:DumpString(a,d) c:DumpInt(b.lineDefined,d) c:DumpInt(b.lastlinedefined,d) c:DumpChar(b.nups,d) c:DumpChar(b.numparams,d) c:DumpChar(b.is_vararg,d) c:DumpChar(b.maxstacksize,d) c:DumpCode(b,d) c:DumpConstants(b,d) c:DumpDebug(b,d)end function e.DumpHeader(b,_)local a=b:header() assert(#a==b.LUAC_HEADERSIZE) b:DumpBlock(a,_)end function e.header(a)local _=1 return a.LUA_SIGNATURE..string.char(a.LUAC_VERSION,a.LUAC_FORMAT,_,4,b,4,8,0)end function e.dump(e,d,c,b,a,_)local f={} f.L=d f.write=b f.data=a f.strip=_ f.status=0 e:DumpHeader(f) e:DumpFunction(c,nil,f) f.write(nil,f.data) return f.status end k.MAXSTACK=250 function k.ttisnumber(_,_)if _ then return type(_.value)=="number"else return false end end function k.nvalue(_,_)return _.value end function k.setnilvalue(_,_)_.value=nil end function k.setsvalue(_,_,a)_.value=a end k.setnvalue=k.setsvalue k.sethvalue=k.setsvalue k.setbvalue=k.setsvalue function k.numadd(_,a,_)return a+_ end function k.numsub(_,a,_)return a-_ end function k.nummul(_,a,_)return a*_ end function k.numdiv(_,a,_)return a/_ end function k.nummod(_,_,a)return _%a end function k.numpow(_,_,a)return _^a end function k.numunm(_,_)return-_ end function k.numisnan(_,_)return not _==_ end k.NO_JUMP=-1 k.BinOpr={OPR_ADD=0,OPR_SUB=1,OPR_MUL=2,OPR_DIV=3,OPR_MOD=4,OPR_POW=5,OPR_CONCAT=6,OPR_NE=7,OPR_EQ=8,OPR_LT=9,OPR_LE=10,OPR_GT=11,OPR_GE=12,OPR_AND=13,OPR_OR=14,OPR_NOBINOPR=15} k.UnOpr={OPR_MINUS=0,OPR_NOT=1,OPR_LEN=2,OPR_NOUNOPR=3} function k.getcode(_,_,a)return _.f.code[a.info]end function k.codeAsBx(b,a,d,c,_)return b:codeABx(a,d,c,_+j.MAXARG_sBx)end function k.setmultret(b,a,_)b:setreturns(a,_,g.LUA_MULTRET)end function k.hasjumps(_,_)return _.t~=_.f end function k.isnumeral(_,a)return a.k=="VKNUM"and a.t==_.NO_JUMP and a.f==_.NO_JUMP end function k._nil(_,a,d,b)if a.pc>a.lasttarget then if a.pc==0 then if d>=a.nactvar then return end else local c=a.f.code[a.pc-1] if j:GET_OPCODE(c)=="OP_LOADNIL"then local _=j:GETARG_A(c) local a=j:GETARG_B(c) if _<=d and d<=a+1 then if d+b-1>a then j:SETARG_B(c,d+b-1)end return end end end end _:codeABC(a,"OP_LOADNIL",d,d+b-1,0)end function k.jump(b,c)local _=c.jpc c.jpc=b.NO_JUMP local a=b:codeAsBx(c,"OP_JMP",0,b.NO_JUMP) a=b:concat(c,a,_) return a end function k.ret(_,a,c,b)_:codeABC(a,"OP_RETURN",c,b+1,0)end function k.condjump(d,e,b,a,_,c)d:codeABC(e,b,a,_,c) return d:jump(e)end function k.fixjump(_,d,c,b)local a=d.f.code[c] local c=b-(c+1) h(b~=_.NO_JUMP) if math.abs(c)>j.MAXARG_sBx then i:syntaxerror(d.ls,"control structure too long")end j:SETARG_sBx(a,c)end function k.getlabel(_,_)_.lasttarget=_.pc return _.pc end function k.getjump(b,_,a)local _=j:GETARG_sBx(_.f.code[a]) if _==b.NO_JUMP then return b.NO_JUMP else return(a+1)+_ end end function k.getjumpcontrol(_,a,b)local _=a.f.code[b] local a=a.f.code[b-1] if b>=1 and j:testTMode(j:GET_OPCODE(a))~=0 then return a else return _ end end function k.need_value(b,a,c)while c~=b.NO_JUMP do local _=b:getjumpcontrol(a,c) if j:GET_OPCODE(_)~="OP_TESTSET"then return true end c=b:getjump(a,c)end return false end function k.patchtestreg(a,_,b,c)local a=a:getjumpcontrol(_,b) if j:GET_OPCODE(a)~="OP_TESTSET"then return false end if c~=j.NO_REG and c~=j:GETARG_B(a)then j:SETARG_A(a,c)else j:SET_OPCODE(a,"OP_TEST") local _=j:GETARG_B(a) j:SETARG_A(a,_) j:SETARG_B(a,0)end return true end function k.removevalues(a,_,b)while b~=a.NO_JUMP do a:patchtestreg(_,b,j.NO_REG) b=a:getjump(_,b)end end function k.patchlistaux(e,d,f,c,b,a)while f~=e.NO_JUMP do local _=e:getjump(d,f) if e:patchtestreg(d,f,b)then e:fixjump(d,f,c)else e:fixjump(d,f,a)end f=_ end end function k.dischargejpc(_,a)_:patchlistaux(a,a.jpc,a.pc,j.NO_REG,a.pc) a.jpc=_.NO_JUMP end function k.patchlist(a,b,_,c)if c==b.pc then a:patchtohere(b,_)else h(c<b.pc) a:patchlistaux(b,_,c,j.NO_REG,c)end end function k.patchtohere(a,b,_)a:getlabel(b) b.jpc=a:concat(b,b.jpc,_)end function k.concat(d,a,_,b)if b==d.NO_JUMP then return _ elseif _==d.NO_JUMP then return b else local c=_ local _=d:getjump(a,c) while _~=d.NO_JUMP do c=_ _=d:getjump(a,c)end d:fixjump(a,c,b)end return _ end function k.checkstack(a,b,_)local _=b.freereg+_ if _>b.f.maxstacksize then if _>=a.MAXSTACK then i:syntaxerror(b.ls,"function or expression too complex")end b.f.maxstacksize=_ end end function k.reserveregs(_,b,a)_:checkstack(b,a) b.freereg=b.freereg+a end function k.freereg(_,a,_)if not j:ISK(_)and _>=a.nactvar then a.freereg=a.freereg-1 h(_==a.freereg)end end function k.freeexp(_,a,b)if b.k=="VNONRELOC"then _:freereg(a,b.info)end end function k.addk(d,f,b,_)local a=f.L local e=f.h[b.value] local c=f.f if d:ttisnumber(e)then return d:nvalue(e)else e={} d:setnvalue(e,f.nk) f.h[b.value]=e g:growvector(a,c.k,f.nk,c.sizek,nil,j.MAXARG_Bx,"constant table overflow") c.k[f.nk]=_ local _=f.nk f.nk=f.nk+1 return _ end end function k.stringK(b,a,_)local c={} b:setsvalue(c,_) return b:addk(a,c,c)end function k.numberK(b,_,a)local c={} b:setnvalue(c,a) return b:addk(_,c,c)end function k.boolK(b,a,_)local c={} b:setbvalue(c,_) return b:addk(a,c,c)end function k.nilK(c,_)local a,b={},{} c:setnilvalue(b) c:sethvalue(a,_.h) return c:addk(_,a,b)end function k.setreturns(a,b,c,_)if c.k=="VCALL"then j:SETARG_C(a:getcode(b,c),_+1)elseif c.k=="VVARARG"then j:SETARG_B(a:getcode(b,c),_+1) j:SETARG_A(a:getcode(b,c),b.freereg) k:reserveregs(b,1)end end function k.setoneret(_,a,b)if b.k=="VCALL"then b.k="VNONRELOC" b.info=j:GETARG_A(_:getcode(a,b))elseif b.k=="VVARARG"then j:SETARG_B(_:getcode(a,b),2) b.k="VRELOCABLE"end end function k.dischargevars(_,a,c)local b=c.k if b=="VLOCAL"then c.k="VNONRELOC"elseif b=="VUPVAL"then c.info=_:codeABC(a,"OP_GETUPVAL",0,c.info,0) c.k="VRELOCABLE"elseif b=="VGLOBAL"then c.info=_:codeABx(a,"OP_GETGLOBAL",0,c.info) c.k="VRELOCABLE"elseif b=="VINDEXED"then _:freereg(a,c.aux) _:freereg(a,c.info) c.info=_:codeABC(a,"OP_GETTABLE",0,c.info,c.aux) c.k="VRELOCABLE"elseif b=="VVARARG"or b=="VCALL"then _:setoneret(a,c)end end function k.code_label(c,d,_,b,a)c:getlabel(d) return c:codeABC(d,"OP_LOADBOOL",_,b,a)end function k.discharge2reg(b,c,d,a)b:dischargevars(c,d) local _=d.k if _=="VNIL"then b:_nil(c,a,1)elseif _=="VFALSE"or _=="VTRUE"then b:codeABC(c,"OP_LOADBOOL",a,(d.k=="VTRUE")and 1 or 0,0)elseif _=="VK"then b:codeABx(c,"OP_LOADK",a,d.info)elseif _=="VKNUM"then b:codeABx(c,"OP_LOADK",a,b:numberK(c,d.nval))elseif _=="VRELOCABLE"then local _=b:getcode(c,d) j:SETARG_A(_,a)elseif _=="VNONRELOC"then if a~=d.info then b:codeABC(c,"OP_MOVE",a,d.info,0)end else h(d.k=="VVOID"or d.k=="VJMP") return end d.info=a d.k="VNONRELOC"end function k.discharge2anyreg(a,b,_)if _.k~="VNONRELOC"then a:reserveregs(b,1) a:discharge2reg(b,_,b.freereg-1)end end function k.exp2reg(f,d,e,c)f:discharge2reg(d,e,c) if e.k=="VJMP"then e.t=f:concat(d,e.t,e.info)end if f:hasjumps(e)then local _ local a=f.NO_JUMP local b=f.NO_JUMP if f:need_value(d,e.t)or f:need_value(d,e.f)then local _=(e.k=="VJMP")and f.NO_JUMP or f:jump(d) a=f:code_label(d,c,0,1) b=f:code_label(d,c,1,0) f:patchtohere(d,_)end _=f:getlabel(d) f:patchlistaux(d,e.f,_,c,a) f:patchlistaux(d,e.t,_,c,b)end e.f,e.t=f.NO_JUMP,f.NO_JUMP e.info=c e.k="VNONRELOC"end function k.exp2nextreg(a,b,_)a:dischargevars(b,_) a:freeexp(b,_) a:reserveregs(b,1) a:exp2reg(b,_,b.freereg-1)end function k.exp2anyreg(_,a,b)_:dischargevars(a,b) if b.k=="VNONRELOC"then if not _:hasjumps(b)then return b.info end if b.info>=a.nactvar then _:exp2reg(a,b,b.info) return b.info end end _:exp2nextreg(a,b) return b.info end function k.exp2val(b,_,a)if b:hasjumps(a)then b:exp2anyreg(_,a)else b:dischargevars(_,a)end end function k.exp2RK(_,b,c)_:exp2val(b,c) local a=c.k if a=="VKNUM"or a=="VTRUE"or a=="VFALSE"or a=="VNIL"then if b.nk<=j.MAXINDEXRK then if c.k=="VNIL"then c.info=_:nilK(b)else c.info=(c.k=="VKNUM")and _:numberK(b,c.nval)or _:boolK(b,c.k=="VTRUE")end c.k="VK" return j:RKASK(c.info)end elseif a=="VK"then if c.info<=j.MAXINDEXRK then return j:RKASK(c.info)end end return _:exp2anyreg(b,c)end function k.storevar(c,d,a,b)local _=a.k if _=="VLOCAL"then c:freeexp(d,b) c:exp2reg(d,b,a.info) return elseif _=="VUPVAL"then local _=c:exp2anyreg(d,b) c:codeABC(d,"OP_SETUPVAL",_,a.info,0)elseif _=="VGLOBAL"then local _=c:exp2anyreg(d,b) c:codeABx(d,"OP_SETGLOBAL",_,a.info)elseif _=="VINDEXED"then local _=c:exp2RK(d,b) c:codeABC(d,"OP_SETTABLE",a.info,a.aux,_)else h(0)end c:freeexp(d,b)end function k._self(c,d,b,_)c:exp2anyreg(d,b) c:freeexp(d,b) local a=d.freereg c:reserveregs(d,2) c:codeABC(d,"OP_SELF",a,b.info,c:exp2RK(d,_)) c:freeexp(d,_) b.info=a b.k="VNONRELOC"end function k.invertjump(_,a,b)local _=_:getjumpcontrol(a,b.info) h(j:testTMode(j:GET_OPCODE(_))~=0 and j:GET_OPCODE(_)~="OP_TESTSET"and j:GET_OPCODE(_)~="OP_TEST") j:SETARG_A(_,(j:GETARG_A(_)==0)and 1 or 0)end function k.jumponcond(b,c,a,_)if a.k=="VRELOCABLE"then local a=b:getcode(c,a) if j:GET_OPCODE(a)=="OP_NOT"then c.pc=c.pc-1 return b:condjump(c,"OP_TEST",j:GETARG_B(a),0,_ and 0 or 1)end end b:discharge2anyreg(c,a) b:freeexp(c,a) return b:condjump(c,"OP_TESTSET",j.NO_REG,a.info,_ and 1 or 0)end function k.goiftrue(c,b,d)local _ c:dischargevars(b,d) local a=d.k if a=="VK"or a=="VKNUM"or a=="VTRUE"then _=c.NO_JUMP elseif a=="VFALSE"then _=c:jump(b)elseif a=="VJMP"then c:invertjump(b,d) _=d.info else _=c:jumponcond(b,d,false)end d.f=c:concat(b,d.f,_) c:patchtohere(b,d.t) d.t=c.NO_JUMP end function k.goiffalse(c,a,d)local b c:dischargevars(a,d) local _=d.k if _=="VNIL"or _=="VFALSE"then b=c.NO_JUMP elseif _=="VTRUE"then b=c:jump(a)elseif _=="VJMP"then b=d.info else b=c:jumponcond(a,d,true)end d.t=c:concat(a,d.t,b) c:patchtohere(a,d.f) d.f=c.NO_JUMP end function k.codenot(a,_,c)a:dischargevars(_,c) local b=c.k if b=="VNIL"or b=="VFALSE"then c.k="VTRUE"elseif b=="VK"or b=="VKNUM"or b=="VTRUE"then c.k="VFALSE"elseif b=="VJMP"then a:invertjump(_,c)elseif b=="VRELOCABLE"or b=="VNONRELOC"then a:discharge2anyreg(_,c) a:freeexp(_,c) c.info=a:codeABC(_,"OP_NOT",0,c.info,0) c.k="VRELOCABLE"else h(0)end c.f,c.t=c.t,c.f a:removevalues(_,c.f) a:removevalues(_,c.t)end function k.indexed(_,a,c,b)c.aux=_:exp2RK(a,b) c.k="VINDEXED"end function k.constfolding(e,c,a,_)local d if not e:isnumeral(a)or not e:isnumeral(_)then return false end local b=a.nval local _=_.nval if c=="OP_ADD"then d=e:numadd(b,_)elseif c=="OP_SUB"then d=e:numsub(b,_)elseif c=="OP_MUL"then d=e:nummul(b,_)elseif c=="OP_DIV"then if _==0 then return false end d=e:numdiv(b,_)elseif c=="OP_MOD"then if _==0 then return false end d=e:nummod(b,_)elseif c=="OP_POW"then d=e:numpow(b,_)elseif c=="OP_UNM"then d=e:numunm(b)elseif c=="OP_LEN"then return false else h(0) d=0 end if e:numisnan(d)then return false end a.nval=d return true end function k.codearith(f,e,c,d,b)if f:constfolding(c,d,b)then return else local a=(c~="OP_UNM"and c~="OP_LEN")and f:exp2RK(e,b)or 0 local _=f:exp2RK(e,d) if _>a then f:freeexp(e,d) f:freeexp(e,b)else f:freeexp(e,b) f:freeexp(e,d)end d.info=f:codeABC(e,c,0,_,a) d.k="VRELOCABLE"end end function k.codecomp(g,f,_,d,e,a)local c=g:exp2RK(f,e) local b=g:exp2RK(f,a) g:freeexp(f,a) g:freeexp(f,e) if d==0 and _~="OP_EQ"then c,b=b,c d=1 end e.info=g:condjump(f,_,d,c,b) e.k="VJMP"end function k.prefix(d,a,_,c)local b={} b.t,b.f=d.NO_JUMP,d.NO_JUMP b.k="VKNUM" b.nval=0 if _=="OPR_MINUS"then if not d:isnumeral(c)then d:exp2anyreg(a,c)end d:codearith(a,"OP_UNM",c,b)elseif _=="OPR_NOT"then d:codenot(a,c)elseif _=="OPR_LEN"then d:exp2anyreg(a,c) d:codearith(a,"OP_LEN",c,b)else h(0)end end function k.infix(a,_,c,b)if c=="OPR_AND"then a:goiftrue(_,b)elseif c=="OPR_OR"then a:goiffalse(_,b)elseif c=="OPR_CONCAT"then a:exp2nextreg(_,b)elseif c=="OPR_ADD"or c=="OPR_SUB"or c=="OPR_MUL"or c=="OPR_DIV"or c=="OPR_MOD"or c=="OPR_POW"then if not a:isnumeral(b)then a:exp2RK(_,b)end else a:exp2RK(_,b)end end k.arith_op={OPR_ADD="OP_ADD",OPR_SUB="OP_SUB",OPR_MUL="OP_MUL",OPR_DIV="OP_DIV",OPR_MOD="OP_MOD",OPR_POW="OP_POW"} k.comp_op={OPR_EQ="OP_EQ",OPR_NE="OP_EQ",OPR_LT="OP_LT",OPR_LE="OP_LE",OPR_GT="OP_LT",OPR_GE="OP_LE"} k.comp_cond={OPR_EQ=1,OPR_NE=0,OPR_LT=1,OPR_LE=1,OPR_GT=0,OPR_GE=0} function k.posfix(e,b,a,c,d)local function _(_,a)_.k=a.k _.info=a.info _.aux=a.aux _.nval=a.nval _.t=a.t _.f=a.f end if a=="OPR_AND"then h(c.t==e.NO_JUMP) e:dischargevars(b,d) d.f=e:concat(b,d.f,c.f) _(c,d)elseif a=="OPR_OR"then h(c.f==e.NO_JUMP) e:dischargevars(b,d) d.t=e:concat(b,d.t,c.t) _(c,d)elseif a=="OPR_CONCAT"then e:exp2val(b,d) if d.k=="VRELOCABLE"and j:GET_OPCODE(e:getcode(b,d))=="OP_CONCAT"then h(c.info==j:GETARG_B(e:getcode(b,d))-1) e:freeexp(b,c) j:SETARG_B(e:getcode(b,d),c.info) c.k="VRELOCABLE" c.info=d.info else e:exp2nextreg(b,d) e:codearith(b,"OP_CONCAT",c,d)end else local _=e.arith_op[a] if _ then e:codearith(b,_,c,d)else local _=e.comp_op[a] if _ then e:codecomp(b,_,e.comp_cond[a],c,d)else h(0)end end end end function k.fixline(_,a,_)a.f.lineinfo[a.pc-1]=_ end function k.code(b,d,a,_)local c=d.f b:dischargejpc(d) g:growvector(d.L,c.code,d.pc,c.sizecode,nil,g.MAX_INT,"code size overflow") c.code[d.pc]=a g:growvector(d.L,c.lineinfo,d.pc,c.sizelineinfo,nil,g.MAX_INT,"code size overflow") c.lineinfo[d.pc]=_ local _=d.pc d.pc=d.pc+1 return _ end function k.codeABC(_,d,e,a,c,b)h(j:getOpMode(e)==j.OpMode.iABC) h(j:getBMode(e)~=j.OpArgMask.OpArgN or c==0) h(j:getCMode(e)~=j.OpArgMask.OpArgN or b==0) return _:code(d,j:CREATE_ABC(e,a,c,b),d.ls.lastline)end function k.codeABx(_,c,d,a,b)h(j:getOpMode(d)==j.OpMode.iABx or j:getOpMode(d)==j.OpMode.iAsBx) h(j:getCMode(d)==j.OpArgMask.OpArgN) return _:code(c,j:CREATE_ABx(d,a,b),c.ls.lastline)end function k.setlist(a,e,b,_,c)local d=math.floor((_-1)/j.LFIELDS_PER_FLUSH)+1 local _=(c==g.LUA_MULTRET)and 0 or c h(c~=0) if d<=j.MAXARG_C then a:codeABC(e,"OP_SETLIST",b,_,d)else a:codeABC(e,"OP_SETLIST",b,_,0) a:code(e,j:CREATE_Inst(d),e.ls.lastline)end e.freereg=b+1 end g.LUA_QS=i.LUA_QS or"'%s'" g.SHRT_MAX=32767 g.LUAI_MAXVARS=200 g.LUAI_MAXUPVALUES=60 g.MAX_INT=i.MAX_INT or 2147483645 g.LUAI_MAXCCALLS=200 g.VARARG_HASARG=1 g.HASARG_MASK=2 g.VARARG_ISVARARG=2 g.VARARG_NEEDSARG=4 g.LUA_MULTRET=-1 function g.LUA_QL(_,_)return"'".._.."'"end function g.growvector(_,_,_,a,_,_,b,_)if a>=b then error(_)end end function g.newproto(_,_)local _={} _.k={} _.sizek=0 _.p={} _.sizep=0 _.code={} _.sizecode=0 _.sizelineinfo=0 _.sizeupvalues=0 _.nups=0 _.upvalues={} _.numparams=0 _.is_vararg=0 _.maxstacksize=0 _.lineinfo={} _.sizelocvars=0 _.locvars={} _.lineDefined=0 _.lastlinedefined=0 _.source=nil return _ end function g.int2fb(_,a)local _=0 while a>=16 do a=math.floor((a+1)/2) _=_+1 end if a<8 then return a else return((_+1)*8)+(a-8)end end function g.hasmultret(_,_)return _=="VCALL"or _=="VVARARG"end function g.getlocvar(_,a,_)return a.f.locvars[a.actvar[_]]end function g.checklimit(_,a,b,d,c)if b>d then _:errorlimit(a,d,c)end end function g.anchor_token(_,_)if _.t.token=="TK_NAME"or _.t.token=="TK_STRING"then end end function g.error_expected(a,b,_)i:syntaxerror(b,string.format(a.LUA_QS.." expected",i:token2str(b,_)))end function g.errorlimit(_,b,_,a)local _=(b.f.linedefined==0)and string.format("main function has more than %d %s",_,a)or string.format("function at line %d has more than %d %s",b.f.linedefined,_,a) i:lexerror(b.ls,_,0)end function g.testnext(_,a,_)if a.t.token==_ then i:next(a) return true else return false end end function g.check(_,b,a)if b.t.token~=a then _:error_expected(b,a)end end function g.checknext(_,b,a)_:check(b,a) i:next(b)end function g.check_condition(_,_,a,b)if not a then i:syntaxerror(_,b)end end function g.check_match(c,d,b,_,a)if not c:testnext(d,b)then if a==d.linenumber then c:error_expected(d,b)else i:syntaxerror(d,string.format(c.LUA_QS.." expected (to close "..c.LUA_QS.." at line %d)",i:token2str(d,b),i:token2str(d,_),a))end end end function g.str_checkname(_,a)_:check(a,"TK_NAME") local _=a.t.seminfo i:next(a) return _ end function g.init_exp(_,b,_,a)b.f,b.t=k.NO_JUMP,k.NO_JUMP b.k=_ b.info=a end function g.codestring(b,a,c,_)b:init_exp(c,"VK",k:stringK(a.fs,_))end function g.checkname(a,b,_)a:codestring(b,_,a:str_checkname(b))end function g.registerlocalvar(b,a,_)local d=a.fs local c=d.f b:growvector(a.L,c.locvars,d.nlocvars,c.sizelocvars,nil,b.SHRT_MAX,"too many local variables") c.locvars[d.nlocvars]={} c.locvars[d.nlocvars].varname=_ local _=d.nlocvars d.nlocvars=d.nlocvars+1 return _ end function g.new_localvarliteral(_,a,c,b)_:new_localvar(a,c,b)end function g.new_localvar(c,a,_,b)local d=a.fs c:checklimit(d,d.nactvar+b+1,c.LUAI_MAXVARS,"local variables") d.actvar[d.nactvar+b]=c:registerlocalvar(a,_)end function g.adjustlocalvars(a,_,b)local c=_.fs c.nactvar=c.nactvar+b for _=b,1,-1 do a:getlocvar(c,c.nactvar-_).startpc=c.pc end end function g.removevars(b,_,a)local _=_.fs while _.nactvar>a do _.nactvar=_.nactvar-1 b:getlocvar(_,_.nactvar).endpc=_.pc end end function g.indexupvalue(a,c,_,b)local d=c.f for a=0,d.nups-1 do if c.upvalues[a].k==b.k and c.upvalues[a].info==b.info then h(d.upvalues[a]==_) return a end end a:checklimit(c,d.nups+1,a.LUAI_MAXUPVALUES,"upvalues") a:growvector(c.L,d.upvalues,d.nups,d.sizeupvalues,nil,a.MAX_INT,"") d.upvalues[d.nups]=_ h(b.k=="VLOCAL"or b.k=="VUPVAL") c.upvalues[d.nups]={k=b.k,info=b.info} local _=d.nups d.nups=d.nups+1 return _ end function g.searchvar(a,c,_)for b=c.nactvar-1,0,-1 do if _==a:getlocvar(c,b).varname then return b end end return-1 end function g.markupval(_,_,a)local _=_.bl while _ and _.nactvar>a do _=_.previous end if _ then _.upval=true end end function g.singlevaraux(e,c,a,d,_)if c==nil then e:init_exp(d,"VGLOBAL",j.NO_REG) return"VGLOBAL"else local b=e:searchvar(c,a) if b>=0 then e:init_exp(d,"VLOCAL",b) if _==0 then e:markupval(c,b)end return"VLOCAL"else if e:singlevaraux(c.prev,a,d,0)=="VGLOBAL"then return"VGLOBAL"end d.info=e:indexupvalue(c,a,d) d.k="VUPVAL" return"VUPVAL"end end end function g.singlevar(_,a,b)local c=_:str_checkname(a) local a=a.fs if _:singlevaraux(a,c,b,1)=="VGLOBAL"then b.info=k:stringK(a,c)end end function g.adjust_assign(a,b,c,_,d)local b=b.fs local c=c-_ if a:hasmultret(d.k)then c=c+1 if c<=0 then c=0 end k:setreturns(b,d,c) if c>1 then k:reserveregs(b,c-1)end else if d.k~="VVOID"then k:exp2nextreg(b,d)end if c>0 then local _=b.freereg k:reserveregs(b,c) k:_nil(b,_,c)end end end function g.enterlevel(_,a)a.L.nCcalls=a.L.nCcalls+1 if a.L.nCcalls>_.LUAI_MAXCCALLS then i:lexerror(a,"chunk has too many syntax levels",0)end end function g.leavelevel(_,_)_.L.nCcalls=_.L.nCcalls-1 end function g.enterblock(_,a,b,_)b.breaklist=k.NO_JUMP b.isbreakable=_ b.nactvar=a.nactvar b.upval=false b.previous=a.bl a.bl=b h(a.freereg==a.nactvar)end function g.leaveblock(_,a)local b=a.bl a.bl=b.previous _:removevars(a.ls,b.nactvar) if b.upval then k:codeABC(a,"OP_CLOSE",b.nactvar,0,0)end h(not b.isbreakable or not b.upval) h(b.nactvar==a.nactvar) a.freereg=a.nactvar k:patchtohere(a,b.breaklist)end function g.pushclosure(a,b,d,_)local e=b.fs local c=e.f a:growvector(b.L,c.p,e.np,c.sizep,nil,j.MAXARG_Bx,"constant table overflow") c.p[e.np]=d.f e.np=e.np+1 a:init_exp(_,"VRELOCABLE",k:codeABx(e,"OP_CLOSURE",0,e.np-1)) for a=0,d.f.nups-1 do local _=(d.upvalues[a].k=="VLOCAL")and"OP_MOVE"or"OP_GETUPVAL" k:codeABC(e,_,0,d.upvalues[a].info,0)end end function g.open_func(_,b,c)local a=b.L local _=_:newproto(b.L) c.f=_ c.prev=b.fs c.ls=b c.L=a b.fs=c c.pc=0 c.lasttarget=-1 c.jpc=k.NO_JUMP c.freereg=0 c.nk=0 c.np=0 c.nlocvars=0 c.nactvar=0 c.bl=nil _.source=b.source _.maxstacksize=2 c.h={}end function g.close_func(a,b)local _=b.L local c=b.fs local _=c.f a:removevars(b,0) k:ret(c,0,0) _.sizecode=c.pc _.sizelineinfo=c.pc _.sizek=c.nk _.sizep=c.np _.sizelocvars=c.nlocvars _.sizeupvalues=_.nups h(c.bl==nil) b.fs=c.prev if c then a:anchor_token(b)end end function g.parser(d,c,a,_,b)local f={} f.t={} f.lookahead={} local e={} e.upvalues={} e.actvar={} c.nCcalls=0 f.buff=_ i:setinput(c,f,a,b) d:open_func(f,e) e.f.is_vararg=d.VARARG_ISVARARG i:next(f) d:chunk(f) d:check(f,"TK_EOS") d:close_func(f) h(e.prev==nil) h(e.f.nups==0) h(f.fs==nil) return e.f end function g.field(_,d,b)local a=d.fs local c={} k:exp2anyreg(a,b) i:next(d) _:checkname(d,c) k:indexed(a,b,c)end function g.yindex(a,b,_)i:next(b) a:expr(b,_) k:exp2val(b.fs,_) a:checknext(b,"]")end function g.recfield(e,f,c)local d=f.fs local a=f.fs.freereg local _,b={},{} if f.t.token=="TK_NAME"then e:checklimit(d,c.nh,e.MAX_INT,"items in a constructor") e:checkname(f,_)else e:yindex(f,_)end c.nh=c.nh+1 e:checknext(f,"=") local _=k:exp2RK(d,_) e:expr(f,b) k:codeABC(d,"OP_SETTABLE",c.t.info,_,k:exp2RK(d,b)) d.freereg=a end function g.closelistfield(_,_,a)if a.v.k=="VVOID"then return end k:exp2nextreg(_,a.v) a.v.k="VVOID" if a.tostore==j.LFIELDS_PER_FLUSH then k:setlist(_,a.t.info,a.na,a.tostore) a.tostore=0 end end function g.lastlistfield(_,a,b)if b.tostore==0 then return end if _:hasmultret(b.v.k)then k:setmultret(a,b.v) k:setlist(a,b.t.info,b.na,_.LUA_MULTRET) b.na=b.na-1 else if b.v.k~="VVOID"then k:exp2nextreg(a,b.v)end k:setlist(a,b.t.info,b.na,b.tostore)end end function g.listfield(a,_,b)a:expr(_,b.v) a:checklimit(_.fs,b.na,a.MAX_INT,"items in a constructor") b.na=b.na+1 b.tostore=b.tostore+1 end function g.constructor(d,e,a)local c=e.fs local _=e.linenumber local b=k:codeABC(c,"OP_NEWTABLE",0,0,0) local f={} f.v={} f.na,f.nh,f.tostore=0,0,0 f.t=a d:init_exp(a,"VRELOCABLE",b) d:init_exp(f.v,"VVOID",0) k:exp2nextreg(e.fs,a) d:checknext(e,"{") repeat h(f.v.k=="VVOID"or f.tostore>0) if e.t.token=="}"then break end d:closelistfield(c,f) local _=e.t.token if _=="TK_NAME"then i:lookahead(e) if e.lookahead.token~="="then d:listfield(e,f)else d:recfield(e,f)end elseif _=="["then d:recfield(e,f)else d:listfield(e,f)end until not d:testnext(e,",")and not d:testnext(e,";") d:check_match(e,"}","{",_) d:lastlistfield(c,f) j:SETARG_B(c.f.code[b],d:int2fb(f.na)) j:SETARG_C(c.f.code[b],d:int2fb(f.nh))end function g.parlist(c,d)local _=d.fs local a=_.f local b=0 a.is_vararg=0 if d.t.token~=")"then repeat local _=d.t.token if _=="TK_NAME"then c:new_localvar(d,c:str_checkname(d),b) b=b+1 elseif _=="TK_DOTS"then i:next(d) c:new_localvarliteral(d,"arg",b) b=b+1 a.is_vararg=c.VARARG_HASARG+c.VARARG_NEEDSARG a.is_vararg=a.is_vararg+c.VARARG_ISVARARG else i:syntaxerror(d,"<name> or "..c:LUA_QL"...".." expected")end until a.is_vararg~=0 or not c:testnext(d,",")end c:adjustlocalvars(d,b) a.numparams=_.nactvar-(a.is_vararg%c.HASARG_MASK) k:reserveregs(_,_.nactvar)end function g.body(d,e,_,a,b)local c={} c.upvalues={} c.actvar={} d:open_func(e,c) c.f.lineDefined=b d:checknext(e,"(") if a then d:new_localvarliteral(e,"self",0) d:adjustlocalvars(e,1)end d:parlist(e) d:checknext(e,")") d:chunk(e) c.f.lastlinedefined=e.linenumber d:check_match(e,"TK_END","TK_FUNCTION",b) d:close_func(e) d:pushclosure(e,c,_)end function g.explist1(b,c,a)local _=1 b:expr(c,a) while b:testnext(c,",")do k:exp2nextreg(c.fs,a) b:expr(c,a) _=_+1 end return _ end function g.funcargs(e,g,a)local d=g.fs local f={} local b local c=g.linenumber local _=g.t.token if _=="("then if c~=g.lastline then i:syntaxerror(g,"ambiguous syntax (function call x new statement)")end i:next(g) if g.t.token==")"then f.k="VVOID"else e:explist1(g,f) k:setmultret(d,f)end e:check_match(g,")","(",c)elseif _=="{"then e:constructor(g,f)elseif _=="TK_STRING"then e:codestring(g,f,g.t.seminfo) i:next(g)else i:syntaxerror(g,"function arguments expected") return end h(a.k=="VNONRELOC") local _=a.info if e:hasmultret(f.k)then b=e.LUA_MULTRET else if f.k~="VVOID"then k:exp2nextreg(d,f)end b=d.freereg-(_+1)end e:init_exp(a,"VCALL",k:codeABC(d,"OP_CALL",_,b+1,2)) k:fixline(d,c) d.freereg=_+1 end function g.prefixexp(b,c,a)local _=c.t.token if _=="("then local _=c.linenumber i:next(c) b:expr(c,a) b:check_match(c,")","(",_) k:dischargevars(c.fs,a)elseif _=="TK_NAME"then b:singlevar(c,a)else i:syntaxerror(c,"unexpected symbol")end return end function g.primaryexp(b,d,c)local a=d.fs b:prefixexp(d,c) while true do local _=d.t.token if _=="."then b:field(d,c)elseif _=="["then local _={} k:exp2anyreg(a,c) b:yindex(d,_) k:indexed(a,c,_)elseif _==":"then local _={} i:next(d) b:checkname(d,_) k:_self(a,c,_) b:funcargs(d,c)elseif _=="("or _=="TK_STRING"or _=="{"then k:exp2nextreg(a,c) b:funcargs(d,c)else return end end end function g.simpleexp(d,c,b)local _=c.t.token if _=="TK_NUMBER"then d:init_exp(b,"VKNUM",0) b.nval=c.t.seminfo elseif _=="TK_STRING"then d:codestring(c,b,c.t.seminfo)elseif _=="TK_NIL"then d:init_exp(b,"VNIL",0)elseif _=="TK_TRUE"then d:init_exp(b,"VTRUE",0)elseif _=="TK_FALSE"then d:init_exp(b,"VFALSE",0)elseif _=="TK_DOTS"then local a=c.fs d:check_condition(c,a.f.is_vararg~=0,"cannot use "..d:LUA_QL"...".." outside a vararg function") local _=a.f.is_vararg if _>=d.VARARG_NEEDSARG then a.f.is_vararg=_-d.VARARG_NEEDSARG end d:init_exp(b,"VVARARG",k:codeABC(a,"OP_VARARG",0,1,0))elseif _=="{"then d:constructor(c,b) return elseif _=="TK_FUNCTION"then i:next(c) d:body(c,b,false,c.linenumber) return else d:primaryexp(c,b) return end i:next(c)end function g.getunopr(_,_)if _=="TK_NOT"then return"OPR_NOT"elseif _=="-"then return"OPR_MINUS"elseif _=="#"then return"OPR_LEN"else return"OPR_NOUNOPR"end end g.getbinopr_table={["+"]="OPR_ADD",["-"]="OPR_SUB",["*"]="OPR_MUL",["/"]="OPR_DIV",["%"]="OPR_MOD",["^"]="OPR_POW",TK_CONCAT="OPR_CONCAT",TK_NE="OPR_NE",TK_EQ="OPR_EQ",["<"]="OPR_LT",TK_LE="OPR_LE",[">"]="OPR_GT",TK_GE="OPR_GE",TK_AND="OPR_AND",TK_OR="OPR_OR"} function g.getbinopr(a,_)local _=a.getbinopr_table[_] if _ then return _ else return"OPR_NOBINOPR"end end g.priority={{6,6},{6,6},{7,7},{7,7},{7,7},{10,9},{5,4},{3,3},{3,3},{3,3},{3,3},{3,3},{3,3},{2,2},{1,1}} g.UNARY_PRIORITY=8 function g.subexpr(d,e,b,_)d:enterlevel(e) local a=d:getunopr(e.t.token) if a~="OPR_NOUNOPR"then i:next(e) d:subexpr(e,b,d.UNARY_PRIORITY) k:prefix(e.fs,a,b)else d:simpleexp(e,b)end local c=d:getbinopr(e.t.token) while c~="OPR_NOBINOPR"and d.priority[k.BinOpr[c]+1][1]>_ do local a={} i:next(e) k:infix(e.fs,c,b) local _=d:subexpr(e,a,d.priority[k.BinOpr[c]+1][2]) k:posfix(e.fs,c,b,a) c=_ end d:leavelevel(e) return c end function g.expr(_,a,b)_:subexpr(a,b,0)end function g.block_follow(_,_)if _=="TK_ELSE"or _=="TK_ELSEIF"or _=="TK_END"or _=="TK_UNTIL"or _=="TK_EOS"then return true else return false end end function g.block(c,a)local b=a.fs local _={} c:enterblock(b,_,false) c:chunk(a) h(_.breaklist==k.NO_JUMP) c:leaveblock(b)end function g.check_conflict(_,_,d,b)local c=_.fs local _=c.freereg local a=false while d do if d.v.k=="VINDEXED"then if d.v.info==b.info then a=true d.v.info=_ end if d.v.aux==b.info then a=true d.v.aux=_ end end d=d.prev end if a then k:codeABC(c,"OP_MOVE",c.freereg,b.info,0) k:reserveregs(c,1)end end function g.assignment(d,e,a,c)local b={} local _=a.v.k d:check_condition(e,_=="VLOCAL"or _=="VUPVAL"or _=="VGLOBAL"or _=="VINDEXED","syntax error") if d:testnext(e,",")then local _={} _.v={} _.prev=a d:primaryexp(e,_.v) if _.v.k=="VLOCAL"then d:check_conflict(e,a,_.v)end d:checklimit(e.fs,c,d.LUAI_MAXCCALLS-e.L.nCcalls,"variables in assignment") d:assignment(e,_,c+1)else d:checknext(e,"=") local _=d:explist1(e,b) if _~=c then d:adjust_assign(e,c,_,b) if _>c then e.fs.freereg=e.fs.freereg-(_-c)end else k:setoneret(e.fs,b) k:storevar(e.fs,a.v,b) return end end d:init_exp(b,"VNONRELOC",e.fs.freereg-1) k:storevar(e.fs,a.v,b)end function g.cond(_,a)local b={} _:expr(a,b) if b.k=="VNIL"then b.k="VFALSE"end k:goiftrue(a.fs,b) return b.f end function g.breakstat(_,_)local b=_.fs local c=b.bl local a=false while c and not c.isbreakable do if c.upval then a=true end c=c.previous end if not c then i:syntaxerror(_,"no loop to break")end if a then k:codeABC(b,"OP_CLOSE",c.nactvar,0,0)end c.breaklist=k:concat(b,c.breaklist,k:jump(b))end function g.whilestat(f,d,b)local e=d.fs local _={} i:next(d) local a=k:getlabel(e) local c=f:cond(d) f:enterblock(e,_,true) f:checknext(d,"TK_DO") f:block(d) k:patchlist(e,k:jump(e),a) f:check_match(d,"TK_END","TK_WHILE",b) f:leaveblock(e) k:patchtohere(e,c)end function g.repeatstat(e,f,_)local d=f.fs local c=k:getlabel(d) local a,b={},{} e:enterblock(d,a,true) e:enterblock(d,b,false) i:next(f) e:chunk(f) e:check_match(f,"TK_UNTIL","TK_REPEAT",_) local _=e:cond(f) if not b.upval then e:leaveblock(d) k:patchlist(f.fs,_,c)else e:breakstat(f) k:patchtohere(f.fs,_) e:leaveblock(d) k:patchlist(f.fs,k:jump(d),c)end e:leaveblock(d)end function g.exp1(_,a)local b={} _:expr(a,b) local _=b.k k:exp2nextreg(a.fs,b) return _ end function g.forbody(g,f,c,_,d,e)local a={} local h=f.fs g:adjustlocalvars(f,3) g:checknext(f,"TK_DO") local b=e and k:codeAsBx(h,"OP_FORPREP",c,k.NO_JUMP)or k:jump(h) g:enterblock(h,a,false) g:adjustlocalvars(f,d) k:reserveregs(h,d) g:block(f) g:leaveblock(h) k:patchtohere(h,b) local a=e and k:codeAsBx(h,"OP_FORLOOP",c,k.NO_JUMP)or k:codeABC(h,"OP_TFORLOOP",c,0,d) k:fixline(h,_) k:patchlist(h,e and a or k:jump(h),b+1)end function g.fornum(d,e,a,_)local c=e.fs local b=c.freereg d:new_localvarliteral(e,"(for index)",0) d:new_localvarliteral(e,"(for limit)",1) d:new_localvarliteral(e,"(for step)",2) d:new_localvar(e,a,3) d:checknext(e,'=') d:exp1(e) d:checknext(e,",") d:exp1(e) if d:testnext(e,",")then d:exp1(e)else k:codeABx(c,"OP_LOADK",c.freereg,k:numberK(c,1)) k:reserveregs(c,1)end d:forbody(e,b,_,1,true)end function g.forlist(d,e,a)local c=e.fs local b={} local f=0 local _=c.freereg d:new_localvarliteral(e,"(for generator)",f) f=f+1 d:new_localvarliteral(e,"(for state)",f) f=f+1 d:new_localvarliteral(e,"(for control)",f) f=f+1 d:new_localvar(e,a,f) f=f+1 while d:testnext(e,",")do d:new_localvar(e,d:str_checkname(e),f) f=f+1 end d:checknext(e,"TK_IN") local a=e.linenumber d:adjust_assign(e,3,d:explist1(e,b),b) k:checkstack(c,3) d:forbody(e,_,a,f-3,false)end function g.forstat(d,e,b)local a=e.fs local _={} d:enterblock(a,_,true) i:next(e) local _=d:str_checkname(e) local c=e.t.token if c=="="then d:fornum(e,_,b)elseif c==","or c=="TK_IN"then d:forlist(e,_)else i:syntaxerror(e,d:LUA_QL"=".." or "..d:LUA_QL"in".." expected")end d:check_match(e,"TK_END","TK_FOR",b) d:leaveblock(a)end function g.test_then_block(a,b)i:next(b) local _=a:cond(b) a:checknext(b,"TK_THEN") a:block(b) return _ end function g.ifstat(b,e,_)local d=e.fs local c=k.NO_JUMP local a=b:test_then_block(e) while e.t.token=="TK_ELSEIF"do c=k:concat(d,c,k:jump(d)) k:patchtohere(d,a) a=b:test_then_block(e)end if e.t.token=="TK_ELSE"then c=k:concat(d,c,k:jump(d)) k:patchtohere(d,a) i:next(e) b:block(e)else c=k:concat(d,c,a)end k:patchtohere(d,c) b:check_match(e,"TK_END","TK_IF",_)end function g.localfunc(b,c)local a,_={},{} local d=c.fs b:new_localvar(c,b:str_checkname(c),0) b:init_exp(a,"VLOCAL",d.freereg) k:reserveregs(d,1) b:adjustlocalvars(c,1) b:body(c,_,false,c.linenumber) k:storevar(d,a,_) b:getlocvar(d,d.nactvar-1).startpc=d.pc end function g.localstat(d,c)local b=0 local _ local a={} repeat d:new_localvar(c,d:str_checkname(c),b) b=b+1 until not d:testnext(c,",") if d:testnext(c,"=")then _=d:explist1(c,a)else a.k="VVOID" _=0 end d:adjust_assign(c,b,_,a) d:adjustlocalvars(c,b)end function g.funcname(a,c,b)local _=false a:singlevar(c,b) while c.t.token=="."do a:field(c,b)end if c.t.token==":"then _=true a:field(c,b)end return _ end function g.funcstat(b,e,a)local c,d={},{} i:next(e) local _=b:funcname(e,c) b:body(e,d,_,a) k:storevar(e.fs,c,d) k:fixline(e.fs,a)end function g.exprstat(a,b)local _=b.fs local c={} c.v={} a:primaryexp(b,c.v) if c.v.k=="VCALL"then j:SETARG_C(k:getcode(_,c.v),1)else c.prev=nil a:assignment(b,c,1)end end function g.retstat(_,a)local e=a.fs local d={} local b,c i:next(a) if _:block_follow(a.t.token)or a.t.token==";"then b,c=0,0 else c=_:explist1(a,d) if _:hasmultret(d.k)then k:setmultret(e,d) if d.k=="VCALL"and c==1 then j:SET_OPCODE(k:getcode(e,d),"OP_TAILCALL") h(j:GETARG_A(k:getcode(e,d))==e.nactvar)end b=e.nactvar c=_.LUA_MULTRET else if c==1 then b=k:exp2anyreg(e,d)else k:exp2nextreg(e,d) b=e.nactvar h(c==e.freereg-b)end end end k:ret(e,b,c)end function g.statement(b,c)local _=c.linenumber local a=c.t.token if a=="TK_IF"then b:ifstat(c,_) return false elseif a=="TK_WHILE"then b:whilestat(c,_) return false elseif a=="TK_DO"then i:next(c) b:block(c) b:check_match(c,"TK_END","TK_DO",_) return false elseif a=="TK_FOR"then b:forstat(c,_) return false elseif a=="TK_REPEAT"then b:repeatstat(c,_) return false elseif a=="TK_FUNCTION"then b:funcstat(c,_) return false elseif a=="TK_LOCAL"then i:next(c) if b:testnext(c,"TK_FUNCTION")then b:localfunc(c)else b:localstat(c)end return false elseif a=="TK_RETURN"then b:retstat(c) return true elseif a=="TK_BREAK"then i:next(c) b:breakstat(c) return true else b:exprstat(c) return false end end function g.chunk(a,b)local _=false a:enterlevel(b) while not _ and not a:block_follow(b.t.token)do _=a:statement(b) a:testnext(b,";") h(b.fs.f.maxstacksize>=b.fs.freereg and b.fs.freereg>=b.fs.nactvar) b.fs.freereg=b.fs.nactvar end a:leavelevel(b)end i:init() local c={} return function(_,a)a=a or'compiled-lua' local _=d:init(d:make_getF(_),nil) if not _ then return end local a=g:parser(c,_,nil,"@"..a) local _,b=e:make_setS() e:dump(c,a,_,b) return b.data end